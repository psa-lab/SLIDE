#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <math.h>
#include "get_matrix.h"
#include "math_util.h"
#include "defs.h"
#include "types.h"
#include "basics.h"
#include <mymalloc.h>

#define TRAC

void transform_center_pts (point_pt cornerpts, 
			   int number_of_center_points,
			   double origin_point[3],
			   double transform_vectors[3][3]) {
  double new_pts[8][3];
  double vector_length[3];
  double origin[3];
  int i, j;

  /* Warn user about point order dependence */
  printf("NOTE: The points in borders.xyz must be in the correct order.\n");
  printf("      If the initial box was generated by make_box_pdb,");
  printf ("it is correct.\n");
  printf("      For details on ordering, see box.gif in SLIDE/docu\n");

#ifdef TRACE
  /* check original */
  for(i=0;i<number_of_center_points;i++) {
    printf("Orig C Pt %2d: ",i+1);
    for (j=0;j<=Z;j++) {
      printf ("%8.3f ",cornerpts[i].pos[j]);
    }
    printf("\n");
  }  
#endif

  /* Copy center pt array to a holder array */
  for (i=0;i<number_of_center_points;i++) {
    for (j=0;j<=Z;j++) {
      new_pts[i][j] = cornerpts[i].pos[j];
    }
  }
  
  /* Find transformation vectors */
  for (i=0;i<=Z;i++) {
    transform_vectors[0][i] = (cornerpts[1].pos[i] - cornerpts[0].pos[i]);
    transform_vectors[1][i] = (cornerpts[2].pos[i] - cornerpts[0].pos[i]);
    transform_vectors[2][i] = (cornerpts[4].pos[i] - cornerpts[0].pos[i]);
  }
  /* Set origin point (equals corner point[0]) */
  for (i=0;i<=Z;i++) {
    origin_point[i] = cornerpts[0].pos[i];
  }

  /* Find vector lengths (equals boxdim) */
  /* Initialize origin pt */
  for (i=0;i<=Z;i++) {
    origin[i] = 0;
  }

  for (i=0;i<=Z;i++) {
    vector_length[i] = distance2(transform_vectors[i],origin);
  }
  
#ifdef TRACE
  /* Check transformation vectors */
  printf("Vec1 (P2P1): ");
  for (i=0;i<=Z;i++)
    printf("+ %7.3f%c ",transform_vectors[0][i],i+120);
  printf (" -- length = %5.2f",vector_length[0]);
  printf("\nVec2 (P3P1): ");
  for (i=0;i<=Z;i++)
    printf("+ %7.3f%c ",transform_vectors[1][i],i+120);
  printf (" -- length = %5.2f",vector_length[1]);
  printf("\nVec3 (P5P1): ");
  for (i=0;i<=Z;i++)
    printf("+ %7.3f%c ",transform_vectors[2][i],i+120);
  printf (" -- length = %5.2f",vector_length[2]);
  printf("\n");
#endif
     

  /* set new corner points */
  /* initial to 0 */
  for (i=0;i<number_of_center_points;i++) {
    for (j=0;j<=Z;j++) {
      cornerpts[i].pos[j] = 0;
    }
  }
  /* set points as necessary */
  cornerpts[1].pos[X] = vector_length[X];
  cornerpts[2].pos[Y] = vector_length[Y];
  cornerpts[3].pos[X] = vector_length[X];
  cornerpts[3].pos[Y] = vector_length[Y];
  cornerpts[4].pos[Z] = vector_length[Z];
  cornerpts[5].pos[X] = vector_length[X];
  cornerpts[5].pos[Z] = vector_length[Z];
  cornerpts[6].pos[Y] = vector_length[Y];
  cornerpts[6].pos[Z] = vector_length[Z];
  cornerpts[7].pos[X] = vector_length[X];
  cornerpts[7].pos[Y] = vector_length[Y];
  cornerpts[7].pos[Z] = vector_length[Z]; 
  
#ifdef TRACE
  /* check new cornerpts */
  for(i=0;i<number_of_center_points;i++) {
    printf("C Pt %2d: ",i+1);
    for (j=0;j<=Z;j++) {
      printf ("%8.3f ",cornerpts[i].pos[j]);
    }
    printf("\n");
  }
#endif
}

void transform_surface_pts (point_pt surface_points, 
			    int number_of_surface_points,
			    double origin_point[3],
			    double transform_vectors[3][3]) {

  point_pt new_pts;
  double rotation_matrix[3][3];
  int i, j, k;
  
  /* SOURCE OF SEGFAULT */
  new_pts = (point_pt) mymalloc (number_of_surface_points 
				 * sizeof (point_t));

  /* Copy surface pt coords to holder */
  for (i=0;i<number_of_surface_points;i++) {
    for (j=0;j<=Z;j++) {
      new_pts[i].pos[j] = surface_points[i].pos[j];
    }
  }

#ifdef TRACE
  /* output original points */
  for (i=0;i<number_of_surface_points;i++) {
    printf("Orig Pt %3d: ",i+1);
    for (j=0;j<=Z;j++) {
      printf("%8.3f ",surface_points[i].pos[j]);
    }
    printf("\n");
  }
#endif

  /* Get rotation matrix */
  get_rotation_matrix(transform_vectors[0],transform_vectors[1],
		      transform_vectors[2],rotation_matrix);
#ifdef TRACE
  /* check rotation matrix */
  printf ("Rotation Matrix\n");
  for (i=0;i<=Z;i++) {
    for (j=0;j<=Z;j++) {
      printf ("%7.4f ",rotation_matrix[i][j]);
    }
    printf ("\n");
  }
  /* check translation matrix */
  printf("Translation Matrix\n");
  for (i=0;i<=Z;i++) {
    printf("%7.4f ",origin_point[i]);
  }
  printf("\n");
#endif

  /* Reinitialize surface points */
  for (i=0;i<number_of_surface_points;i++) {
    for (j=0;j<=Z;j++) {
      surface_points[i].pos[j] = 0.0;
    }
  }
  /* Apply rotation matrtix */
  for (i=0;i<number_of_surface_points;i++) {
    for (j=0;j<=Z;j++) {
      for (k=0;k<=Z;k++) {
	surface_points[i].pos[j]+= (new_pts[i].pos[k] 
				    * rotation_matrix[j][k]);
      }
    }
  }   
  
#ifdef TRACE
  /* check rotated surface points */
  for (i=0;i<number_of_surface_points;i++) {
    printf("Rotd Pt %3d: ",i+1);
    for (j=0;j<=Z;j++) {
      printf("%8.3f ",surface_points[i].pos[j]);
    }
    printf("\n");
  }
#endif

  /* Apply translation matrix */
  for (i=0;i<number_of_surface_points;i++) {
    for (j=0;j<=Z;j++) {
      surface_points[i].pos[j] += origin_point[j];
    }
  }
#ifdef TRACE
  /* check rotated & translated surface points */
    for (i=0;i<number_of_surface_points;i++) {
    printf("Trad Pt %3d: ",i+1);
    for (j=0;j<=Z;j++) {
      printf("%8.3f ",surface_points[i].pos[j]);
    }
    printf("\n");
  }
#endif

}
